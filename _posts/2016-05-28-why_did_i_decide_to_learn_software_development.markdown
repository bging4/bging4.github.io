---
layout: post
title:  "Why did I decide to learn software development?"
date:   2016-05-28 16:33:59 +0000
---

The short answer is because I enjoy it. But that’s not a blog post, nor is it particularly illuminating for readers out there. So I’ll look at it a bit closer.

As background, until a year or two ago, I had never considered software development. The idea of coding as an activity, much less a career, seemed about as appealling to me as…well, let’s just say it was never on my radar. I was always more of a humanities person. I loved literature, languages, history, and philosophy. I’ve studied Chinese, Japanese, Spanish, German, and Latin; and some of my favorite classes in college were Political Philosophy and Classical Political Thought, where I read the Greeks, the early Christian Philosophers, Hobbes, Locke, Burke, etc. 

Because of these interests, I attended a joint degree program at Georgetown University, where I earned a JD and an MA in Security Studies.

Enough about my biography. How did I get from these interests and a policy/legal career to software development?

Partly by chance. Because of my interest in security, I began studying cyber security. I found it to be challenging (unsurprisingly), but also (surprisingly) very interesting. On a whim, I picked up a copy of *Learning Python the Hard Way* by Zed Shaw. I’m not sure why I tried Python—I knew pretty much nothing about programming languages. Perhaps the Monty Python connection? Regardless, I considered myself to be reasonably tech-saavy, but as I started the book, I was continually amazed at what I didn’t know. The terminal? Sure, I knew there was some kind of way to type in direct commands, but I had no idea that it could actually be quicker and more convenient than pointing and clicking on folders and documents. 

As I progressed through the book, I stumbled upon other realizations. I had imagined coding to be a boring process, involving long, non-sensical series of numbers and characters, tons of math, and rote memorization. But this was not the case—far from it. More than anything else, I realized that Python is a language. Very different from a human language, to be sure, but still a means of communication. Even more mind-boggling, things like style and clarity matter, because other people might read your code and need to understand your intent. 

I also found that, while similar to human language, it differed in key respects. Most significantly, the logic was highly precise. As an attorney, this made sense to me. (I was practicing immigration law at the time, and the logical clarity built into Python was a relief compared to the rhetorical gymnastics and the conflicting and ever-changing definitions of key legal concepts I was used to).

Intrigued, I continued to study programming on my own, learning some basic HTML and CSS, Javascript, trying some Swift tutorials, and even trying a little Ruby. 

As I messed around with different programming languages I realized all that programming has to offer. Not only is it intellectually challenging, but it forces you to approach problems in a deliberate way. Self-mastery seems like too grandiose a term for what I mean here, but there is no denying that programming forces you to become more aware of your thought processes, examine your assumptions, and confront the gap between what you *really* know and what you *think* you know. Like good social science or legal writing, before you start, you have to know the precise meaning of the terms you are using. For example, say you want to take an array of numbers in Ruby and use them as indexes to place command line input within another array. It’s not too hard to understand what an array is, but you need to know a lot more to actually solve this problem. And it is not just looking things up—that is often the easiest part. The hardest part, just like in good writing, is *translating what you mean (or what you want to happen) into the clearest, simplest terms possible.* This is where you realize what you really know, and what you just think you know. And I quickly learned that when I ignored this step, things did not work out as I planned. 

So programming teaches you this self-discipline. There’s always the urge to dive right in and improvise, but to do the best work, you have to stop and think. And by think, I mean really *think*. This type of deliberate thought is not easy, but I believe that it not only builds mental discipline, but it helps you approach other problems in a more methodical, comprehensive way. 

Finally, I realized that with programming, the creative possibilities are practically endless.  The ability to take an idea and turn it into an interactive experience is exciting. Programming skills can be applied to so many problems and questions. This creative element, combined with the intellectual challenge, convinced me that I wanted to seriosuly learn software development. 
